<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width"><meta name="description" content="" />

<title>
    
    Driving GPU based particles using 2D textures, Unity | Nicolas Mars
    
</title>







<link rel="stylesheet" href="/assets/combined.min.1a597bf3003b05ec92c50a54bac838f208bbbf98769520c89cfb1a7633c5e3c5.css" media="all">




  



  </head>

  

  
  
  

  <body class="dark">

    <div class="content">
      <header>
        

<div class="header">
    <h1 class="header-title">Nicolas Mars</h1>

    <div class="flex">
        

        
        
        <p class="small ">
            <a href="/">
                /home
            </a>
        </p>
        
        <p class="small ">
            <a href="/about">
                /about
            </a>
        </p>
        
        <p class="small ">
            <a href="/posts">
                /posts
            </a>
        </p>
        
        <p class="small ">
            <a href="/projects">
                /projects
            </a>
        </p>
        
        
    </div>

</div>
      </header>

      <main class="main">
        




<div class="breadcrumbs">
    
    <a href="/">Home</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a href="/posts/">Posts</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a class="breadcrumbs-current" href="/posts/drivingparticles/">Driving GPU based particles using 2D textures, Unity</a>
</div>


<div  class="autonumber" >

  <div class="single-intro-container">

    

    <h1 class="single-title">Driving GPU based particles using 2D textures, Unity</h1>
    
    <p class="single-summary">Millions of particles for the cost of a single render pass</p>
    

    

    <p class="single-readtime">
      
      
      
      <time datetime="2024-05-05T00:00:00&#43;00:00">May 5, 2024</time>
      

      
      &nbsp; Â· &nbsp;
      3 min read
      
    </p>

  </div>

  

  

  
  <aside class="toc">
    <p><strong>Table of contents</strong></p>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#problems">Problems</a></li>
    <li><a href="#resolutions">Resolutions</a>
      <ul>
        <li><a href="#following-a-path">Following a path</a></li>
        <li><a href="#gravity">Gravity</a></li>
      </ul>
    </li>
    <li><a href="#workflow">Workflow</a></li>
  </ul>
</nav>
  </aside>
  

  

  <div class="single-content">
    <h2 id="problems">Problems</h2>
<ul>
<li>
<p>How to implement a light-weighted particle system in the Unity built-in render pipeline, computed on the GPU, easy to use and compatible with a maximum amount of targets ?</p>
</li>
<li>
<p>How to have millions of particles following a hand-drawn path, reacting to gravity, and colliding on obstacles ?</p>
</li>
<li>
<p>How to make the system efficient enough in order to instantiate dozens of them in a scene ?</p>
</li>
<li>
<p>How to make all of this running without the convenience of compute shaders or compute buffer (for compatibility purposes) ?</p>
</li>
</ul>
<h2 id="resolutions">Resolutions</h2>
<p>We ended up using 2D data textures (single or textures array, here called <em>field textures</em>), <em>linked</em> to the scene through a quad. From its transform, we could easily compute matrices relatives to the system&rsquo;s bounds, and use theses in the simulation shader to get particle&rsquo;s uv and convert vector data from texture space to domain space.</p>
<pre tabindex="0"><code>// C# pseudo code
void ComputeMatrices(Bounds domain, Transform quadTransform)
{
    Matrix4x4 FieldToDomain = Matrix4x4.TRS(
        domain.origin,                  // world position
        Quaternion.identity,            // bypass rotation 
        MinComponent(domain.extents)    // preserve ratio
    ).inverse;
    
    FieldToDomain *= quadTransform.localToWorldMatrix;
    DomainToField  = FieldToDomain.inverse;
}
</code></pre><p>Packing as much data as possible in a single texture is key here, for optimisation purposes but also for readability and usability.</p>
<h3 id="following-a-path">Following a path</h3>
<p><video class="video-shortcode" preload="auto" controls >
    <source src="0.mp4" type="video/mp4">
    There should have been a video here but your browser does not seem
    to support it.
</video>













<figure class="">

    <div>
        <img loading="lazy" alt="img" src=" 0.jpg">
    </div>

    
</figure></p>
<p>To drive particles along a path (shape), we use a signed distance field to the outlines of the path, normals of the path for collisions and constaints, a path direction vector and finally an height map to raise the system to a third dimension, following a relief.<br>
To see how SDF and directions can be computed from 2D drawings, check the post <em>sdfGenerators</em></p>
<p>A 4 component&rsquo;s texture (float or half) can pack everything, such as :</p>
<pre tabindex="0"><code>// HLSL pseudo code
float4 col = _PathTex[uv * dim] // hlsl direct access
struct PathData
{
    // red + green
    float3 shapeNormal;         // float3(normalize(col.rg), 0)
    float distanceToShape;      // length(col.rg) * 2.0 - 1.0

    // blue + alpha
    float3 pathDirection;       // float3(normalize(col.ba), 0)
    float height;               // length(col.ba) * 2.0 - 1.0
}
// to get the vectors oriented in scene 
shapeNormal = mul(FieldToDomain, float4(shapeNormal,0)).xyz;
</code></pre><p>This kind of texture doesn&rsquo;t need to be more defined than 512x512 pixels.
Since we now have the distance to the path outlines and its normals, having the particle colling and reflecting is as simple as :</p>
<pre tabindex="0"><code>// HLSL
#define epsilon 0.01
if(distance &lt; epsilon) velocity = reflect(normal, velocity);
</code></pre><h3 id="gravity">Gravity</h3>
<video class="video-shortcode" preload="auto" controls >
    <source src="1.mp4" type="video/mp4">
    There should have been a video here but your browser does not seem
    to support it.
</video>


<p>To compute gravity and collision with topography, we pre-compute normals from an height map.
Data textures for the gravity encapsulate at least 3D normals and the height map, such as :</p>
<pre tabindex="0"><code>// HLSL pseudo code
float4 col = _TopoTex[uv * dim] // hlsl direct access
struct TopoData
{
    // red + green + blue
    float3 normals;             // normalize(col.rgb)
    float height;               // length(col.rgb) * 2.0 - 1.0

    // alpha
    float zone;                 // col.a, optional
}
</code></pre><p>By converting the particle&rsquo;s position to field space (by using the DomainToField matrix) we can compare its Z component with the height value (from the data texture), if less, we can once again reflect the particle velocity around</p>
<h2 id="workflow">Workflow</h2>
<p><video class="video-shortcode" preload="auto" controls >
    <source src="2.mp4" type="video/mp4">
    There should have been a video here but your browser does not seem
    to support it.
</video>


<video class="video-shortcode" preload="auto" controls >
    <source src="3.mp4" type="video/mp4">
    There should have been a video here but your browser does not seem
    to support it.
</video>

</p>
<p>This will be released on Github very soon :)</p>

    
  </div>

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


      </main>
    </div>

    <footer>
      


<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>

    </footer>

  </body>

  <script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    document.body.classList.remove("auto");
    let cls = "light";
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);
  }

  function invertBody() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invertBody);
  }

  setTheme();

</script>

</html>